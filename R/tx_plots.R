#' Nucleotide frequency plot
#'
#' Generates a ggplot barplot using the nucleotide frequency counts in
#' data.tables generated by tx_covNucFreqDT().
#'
#' @param DT data.table. Input data from which to generate the plot
#' @param gene character. Name of the gene in DT which wants to be plotted.
#' @param txRange integer. Range in data to be used, 'txcoor' column is used to
#' delimit this range in the data.table.
#' @param removeInsert logical. Removes counts from insert reads, which do not
#' call for a nucleotide, are just the gap between read1 and read2.
#' @param makePlotly logical. Outputs an interactive plot by using the ggplotly()
#' function.
#' @param show_yLabels logical. If set to FALSE hides the y axis labels.
#' @param bar_border logical. If set to FALSE removes the border of the bars.
#' @param showLegend logical. If set to FALSE does not renger a legend.
#'
#' @return ggplot
#' @export
#'
tx_plot_nucFreq <- function(DT,
                            gene,
                            txRange = 1:nrow(DT),
                            removeInsert = T,
                            makePlotly = F,
                            show_yLabels = T,
                            bar_border = T,
                            showLegend = T){
    check_refSeq(DT)
    DT <- check_DT(DT)
    allCols <- all(c("refSeq", "A", "C", "G", "T", "-", "N") %in% names(DT))
    if(!allCols){
        stop("DT must containg the reference sequence column 'refSeq' along ",
             "nucleotide frequency columns 'A', 'C', 'G', 'T', 'N', and '-'")
    }
    if(!(gene %in% DT$gene)){stop("gene not found in DT object")}
    DT <- DT[DT$gene == gene,]
    DT <- DT[DT$txcoor %in% txRange,]
    DT$REF <- 0
    nucsInRef <- unique(DT$refSeq)
    for(i in nucsInRef){
        DT[which(DT$refSeq == i),"REF"] <- DT[which(DT$refSeq == i), i,  with = F]
        DT[which(DT$refSeq == i), i] <- 0
    }
    DT$pos <- paste(DT$txcoor, DT$refSeq, sep = "-")
    DT$pos <- factor(DT$pos, levels = DT$pos)
    tmpData <- tidyr::pivot_longer(DT, cols = c(txtools::IUPAC_code_simpl, "REF"),
                                   values_to = "counts", names_to = "nuc") %>% data.table::data.table()
    if(removeInsert){
        tmpData <- tmpData[tmpData$nuc != ".",]
        tmpData$nuc <- factor(tmpData$nuc, levels = c("REF", "A", "C", "G", "T", "-", "N"))
        tmpGG <- ggplot2::ggplot(tmpData, ggplot2::aes(x = tmpData$pos,
                                                       y = tmpData$counts,
                                                       fill = tmpData$nuc)) +
            ggplot2::theme_minimal() + scale_fill_txBrowser_2() +
            ggplot2::ylab("Frequency") + ggplot2::xlab("Transcriptome coordinate") +
            ggplot2::theme(legend.position="bottom") +
            ggplot2::guides(fill= ggplot2::guide_legend(nrow = 1, byrow=TRUE, title = "")) +
            ggplot2::ggtitle(gene)
    }else{
        tmpData$nuc <- factor(tmpData$nuc, levels = c(".", "REF", "A", "C", "G", "T", "-", "N"))
        tmpGG <- ggplot2::ggplot(tmpData, ggplot2::aes(x = tmpData$pos,
                                                       y = tmpData$counts,
                                                       fill = tmpData$nuc)) +
            ggplot2::theme_minimal() + scale_fill_txBrowser() +
            ggplot2::ylab("Frequency") + ggplot2::xlab("Transcriptome coordinate") +
            ggplot2::theme(legend.position="bottom") +
            ggplot2::guides(fill= ggplot2::guide_legend(nrow = 1, byrow = TRUE, title = "")) +
            ggplot2::ggtitle(gene)
    }
    if(bar_border){
        tmpGG <- tmpGG + ggplot2::geom_bar(stat = "identity", colour = "black", size = 0.3)
    }else{
        tmpGG <- tmpGG + ggplot2::geom_bar(stat = "identity")
    }
    if(show_yLabels){
        nucCols <- txBrowser_pal()(6)[-1:-2][as.numeric(factor(DT$refSeq))]
        tmpGG <- suppressWarnings(
            tmpGG +
                ggplot2::theme(axis.text.x =
                                   ggplot2::element_text(angle = 90, hjust = 1,
                                                         vjust = 0.5,
                                                         colour = nucCols,
                                                         face = "bold")))
    }else{
        tmpGG <- tmpGG + ggplot2::theme(axis.text.x = ggplot2::element_blank())
    }
    if(!showLegend){
        tmpGG <- tmpGG + ggplot2::theme(legend.position="none")
    }
    if(makePlotly){
        plotly::ggplotly(tmpGG)
    }else{
        tmpGG
    }
}




#' Transcript coverage plot highlighting read-starts and read-ends counts
#'
#' @param DT data.table or data.frame. Input data from which to generate the plot
#' @param gene character. Name of the gene in DT which wants to be plotted.
#' @param txRange integer. Range in data to be used, 'txcoor' column is used to
#' delimit this range in the data.table.
#' @param removeCov logical. If set to TRUE remove coverage counts.
#' @param makePlotly logical. Outputs an interactive plot by using the ggplotly()
#' function.
#' @param show_yLabels logical. If set to FALSE hides the y axis labels.
#' @param bar_border logical. If set to FALSE removes the border of the bars.
#' @param showLegend logical. If set to FALSE does not renger a legend.
#'
#' @return ggplot
#' @export
#'
#' @examples
tx_plot_staEndCov <- function(
    DT, gene, txRange = 1:nrow(DT), makePlotly = FALSE, removeCov = FALSE,
    show_yLabels = TRUE, bar_border = TRUE, showLegend = TRUE){
    check_refSeq(DT)
    DT <- check_DT(DT)
    if(!(gene %in% DT$gene)){stop("gene not found in DT object")}
    DT <- DT[DT$gene == gene,]
    DT <- DT[DT$txcoor %in% txRange,]
    DT$pos <- paste(DT$txcoor, DT$refSeq, sep = "-")
    DT$pos <- factor(DT$pos, levels = DT$pos)
    DT$cov <- DT$cov - DT$start_5p - DT$end_3p
    if(removeCov){DT$cov <- 0}
    tmpData <- tidyr::pivot_longer(DT, cols = c("start_5p", "end_3p", "cov"),
                                   values_to = "counts", names_to = "coverage") %>%
        data.table::data.table()
    tmpData$coverage <- factor(tmpData$coverage, levels = c("cov",
                                                            "start_5p",
                                                            "end_3p"))
    tmpGG <- ggplot2::ggplot(tmpData,
                             ggplot2::aes(x = tmpData$pos,
                                          y = tmpData$counts,
                                          fill = tmpData$coverage)) +
        ggplot2::theme_minimal() +
        ggplot2::scale_fill_manual(values = c("#c2c2c2", "#5b54a0", "#f1876d")) +
        ggplot2::ylab("Frequency") + ggplot2::xlab("Transcriptome coordinate") +
        ggplot2::theme(legend.position="bottom") +
        ggplot2::guides(fill = ggplot2::guide_legend(nrow=1, byrow=TRUE, title = "")) +
        ggplot2::ggtitle(gene)
    if(bar_border){
        tmpGG <- tmpGG + ggplot2::geom_bar(stat = "identity",
                                           colour = "black",
                                           size = 0.3)
    }else{
        tmpGG <- tmpGG + ggplot2::geom_bar(stat = "identity")
    }
    if(show_yLabels){
        nucCols <- txBrowser_pal()(6)[-1:-2][as.numeric(factor(DT$refSeq))]
        tmpGG <- suppressWarnings(
            tmpGG +
                ggplot2::theme(axis.text.x =
                                   ggplot2::element_text(angle = 90,
                                                         hjust = 1,
                                                         vjust = 0.5,
                                                         colour = nucCols,
                                                         face = "bold")))
    }else{
        tmpGG <- tmpGG + ggplot2::theme(axis.text.x = ggplot2::element_blank())
    }
    if(!showLegend){
        tmpGG <- tmpGG + ggplot2::theme(legend.position="none")
    }
    if(makePlotly){
        plotly::ggplotly(tmpGG)
    }else{
        tmpGG
    }
}


tx_plot_metaGeneByBins <- function(DT, colName, nBins = 100, FUN = "mean", minTxLength = 300,
                                   minReadsPerGene = 100, smooth = TRUE, na.rm = TRUE){
    if(nBins >= minTxLength){stop("Number of bins most be smaller than minimum",
                                  "transcript length.")}
    if(!(colName %in% colnames(DT))){stop("colName is not a column in DT.")}
    nStarts <- DT[, sum(start_5p), by = gene][order(V1, decreasing = T),]
    DT <- DT[gene %in% nStarts$gene[nStarts$V1 >= minReadsPerGene]]
    geneLens <- tx_get_geneLengths(DT)
    DT <- DT[gene %in% names(geneLens)[geneLens > minTxLength]]
    GENES <- as.character(unique(DT$gene))
    if(length(GENES) < 1){stop("No genes after filtering parameters")}
    meanCovBinned <- mclapply(seq(GENES), function(i){
        iGene <- GENES[i]
        tmpDT <- DT[gene == iGene,]
        tmpDT$group <- tmpDT$txcoor %>% cut_number(n = nBins)
        out <- tapply(tmpDT[[colName]], tmpDT$group, FUN, na.rm = na.rm)
        out[is.nan(out)] <- NA
        out
    }) %>% do.call(what = rbind) %>% apply(MARGIN = 2, FUN = FUN, na.rm = na.rm) %>% set_names(NULL)
    DF <- data.frame(bins = seq(meanCovBinned) %>% as.numeric,
                     score = meanCovBinned)
    plotTitle <- paste("METAGENE BY BINS -", FUN, colName) %>% toupper()
    plotSub <- paste0("n(genes) =", length(GENES), ", minTxLen =", minTxLength,
                      ", minReadsPerGene =", minReadsPerGene, ", smooth.sp =", smooth)
    Y_axis <- paste(FUN, colName)
    if(smooth){
        DF$smooth <- smooth.spline(DF$score)$y
        ggplot(DF, aes(x = bins, y = smooth)) + geom_line() + theme_classic() +
            ggtitle(plotTitle, plotSub) + ylab(Y_axis)
    }else{
        ggplot(DF, aes(x = bins, y = score)) + geom_line() + theme_classic() +
            ggtitle(plotTitle, plotSub) + ylab(Y_axis)
    }
}


#' Plot motif centered in logical annotation
#'
#' Plots a motif of the sequence surrounding sites marked as TRUE in a logical
#' vector in a
#'
#' @param DT
#' @param logi_col
#' @param upFlank
#' @param doFlank
#' @param method
#'
#' @return
#' @export
#'
#' @examples
tx_plot_ggseqlogo <- function(DT, logi_col, upFlank, doFlank, method = "bits"){
    tmpO <- tx_get_flankSequence(DT = DT, logi_col = logi_col, upFlank = upFlank, doFlank = doFlank)
    ggOUT <- ggseqlogo::ggseqlogo(tmpO, method = method) + ggplot2::theme_minimal() +
        ggplot2::ggtitle(paste0("SegLogo at '", logi_col, "' sites"), paste("n =", length(tmpO)))
    if(method == "bits"){
        ggOUT + ggplot2::ylim(0,2)
    }else{
        ggOUT
    }
}


tx_plot_metageneAtCDS <- function(txDT, geneAnnotation, colVars, CDS_align, upFlank,
                                  doFlank, summ_fun = "sum", roll_fun = "sum", roll_n = 100,
                                  roll_align = "center", roll_fill = NA, smooth = TRUE, spar  = 0.3,
                                  na.rm = TRUE, normalize = TRUE, tick_by = NULL){
    tmpO <- tx_get_metageneAtCDS(txDT = txDT, geneAnnotation = geneAnnotation, colVars = colVars,
                                 CDS_align = CDS_align, upFlank = upFlank, doFlank = doFlank)
    tmpDF <- lapply(names(tmpO), function(x){
        if(summ_fun == "sum"){
            tmp2 <- colSums(tmpO[[x]], na.rm = na.rm)
        }else if(summ_fun == "mean"){
            tmp2 <- colMeans(tmpO[[x]], na.rm = na.rm)
        }else{stop("Argument 'summ_fun' has to be either sum or mean")}
        if(is.null(roll_fun)){
            tmp3 <- tmp2
        }else if(roll_fun == "sum"){
            tmp3 <- RcppRoll::roll_sum(tmp2, n = roll_n, align = roll_align, fill = roll_fill, na.rm = na.rm)
        }else if(roll_fun == "mean"){
            tmp3 <- RcppRoll::roll_mean(tmp2, n = roll_n, align = roll_align, fill = roll_fill, na.rm = na.rm)
        }else{stop("Argument 'roll_fun' has to be either sum or mean")}
        tmpDF <- data.frame(value = tmp3, position = factor(names(tmp2), levels = names(tmp2)), group = x)
        if(smooth){
            tmpDF[!is.na(tmpDF$value), ]$value <- stats::smooth.spline(tmpDF[!is.na(tmpDF$value), ]$value, spar = spar)$y
        }
        if(normalize){
            tmpDF$value <- (tmpDF$value / sum(tmpDF$value, na.rm = TRUE)) * 100
        }
        tmpDF
    }) %>% do.call(what = "rbind") %>% data.table::data.table()
    if(is.null(tick_by)){
        tick_by <- upFlank / 2
    }
    tmpGG <- ggplot(tmpDF, aes(x = position, y = value, group = group, colour = group)) +
        geom_line() +
        scale_x_discrete(limits = unique(tmpDF$position),
                         breaks = unique(tmpDF$position)[seq(1, length(unique(tmpDF$position)), by = tick_by)]) +
        theme_minimal() + theme(axis.text.x = element_text(angle = 90, hjust = 1))
    if(CDS_align == "end"){
        tmpGG <- tmpGG + ggplot2::geom_vline(xintercept = "CDS_end" , col = "black", linetype="dashed") +
            ggtitle("Metagene aligned at CDS_end")
    }else if(CDS_align == "start"){
        tmpGG <- tmpGG + ggplot2::geom_vline(xintercept = "CDS_start" , col = "black", linetype="dashed") +
            ggtitle("Metagene aligned at CDS_start")
    }
    tmpGG
}

tx_plot_oneNumeric <- function(DTL, gene, txRange = 1:nrow(DTL[[1]]), columnName,
                               makePlotly = FALSE, show_yLabels = TRUE,
                               bar_border = TRUE, showLegend = TRUE,
                               col = "#c2c2c2"){
    if(all(is(DTL) %in% is(list()))){
        lapply(DTL, function(x) check_refSeq(x))
        DTL <- lapply(DTL, function(x) check_DT(x))
        if(!all(unlist(lapply(DTL, function(x) gene %in% x$gene)))){stop("gene not found in DT object")}
        if(is.null(names(DTL))){names(DTL) <- seq_along(DTL)}
        tmpData <- lapply(seq_along(DTL), function(i){
            DT <- DTL[[i]]
            DT <- DT[DT$gene == gene, ]
            DT <- DT[DT$txcoor %in% txRange,]
            DT$pos <- paste(DT$txcoor, DT$refSeq, sep = "-")
            DT$pos <- factor(DT$pos, levels = DT$pos)
            tmpData <- tidyr::pivot_longer(DT, cols = all_of(columnName),
                                           values_to = "counts",
                                           names_to = "coverage") %>%
                data.table::data.table()
            tmpData$coverage <- factor(tmpData$coverage, levels = columnName)
            tmpData$sample <- names(DTL)[i]
            tmpData
        }) %>% do.call(what = rbind)
    }else{
        DT <- DTL
        DT <- check_refSeq(DT)
        DT <- check_DT(DT)
        DT <- as.data.frame(DT)
        if(!(gene %in% DT$gene)){stop("gene not found in DT object")}
        DT <- DT[DT$gene == gene, ]
        DT <- DT[DT$txcoor %in% txRange,]
        DT$pos <- paste(DT$txcoor, DT$refSeq, sep = "-")
        DT$pos <- factor(DT$pos, levels = DT$pos)
        tmpData <- tidyr::pivot_longer(DT, cols = all_of(columnName),
                                       values_to = "counts",
                                       names_to = "coverage") %>%
            data.table::data.table()
        tmpData$coverage <- factor(tmpData$coverage, levels = columnName)
    }
    tmpGG <- ggplot2::ggplot(tmpData,
                             ggplot2::aes(x = tmpData$pos,
                                          y = tmpData$counts,
                                          fill = tmpData$coverage)) +
        ggplot2::theme_minimal() +
        ggplot2::scale_fill_manual(values = col) +
        ggplot2::ylab(columnName) + ggplot2::xlab("Transcriptome coordinate") +
        ggplot2::theme(legend.position="none") +
        ggplot2::guides(fill = ggplot2::guide_legend(nrow=1, byrow=TRUE, title = "")) +
        ggplot2::ggtitle(gene)
    if(bar_border){
        tmpGG <- tmpGG + ggplot2::geom_bar(stat = "identity",
                                           colour = "black",
                                           size = 0.3)
    }else{
        tmpGG <- tmpGG + ggplot2::geom_bar(stat = "identity")
    }
    if(show_yLabels){
        if(all(is(DTL) == is(list()))){
            tmpDT <- DTL[[1]]
            nucCols <- txBrowser_pal()(6)[-1:-2][as.numeric(factor(tmpDT[tmpDT$gene == gene & tmpDT$txcoor %in% txRange, ]$refSeq))]
        }else{
            nucCols <- txBrowser_pal()(6)[-1:-2][as.numeric(factor(DTL$refSeq))]
        }
        tmpGG <- suppressWarnings(
            tmpGG +
                ggplot2::theme(axis.text.x =
                                   ggplot2::element_text(angle = 90,
                                                         hjust = 1,
                                                         vjust = 0.5,
                                                         colour = nucCols,
                                                         face = "bold")))
    }else{
        tmpGG <- tmpGG + ggplot2::theme(axis.text.x = ggplot2::element_blank())
    }
    if(!showLegend){
        tmpGG <- tmpGG + ggplot2::theme(legend.position="none")
    }
    if(all(is(DTL) == is(list()))){
        tmpGG <- tmpGG + facet_wrap(sample~.)
    }
    if(makePlotly){
        plotly::ggplotly(tmpGG)
    }else{
        tmpGG
    }
}
