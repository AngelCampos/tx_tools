---
output: github_document
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# txtools

<!-- badges: start -->
<!-- badges: end -->

**txtools** is a package that processes GenomicAlignments objects into their 
transcriptomic versions.

**txtools** is meant to expand the functionality of the 
[**GenomicAlignments**](https://bioconductor.org/packages/release/bioc/html/GenomicRanges.html)
package, as currently it does not support transcriptomic-wise features. 
Transcriptomic-wise or gene-models-aware featuresare increasingly needed to
process and analyze RNA-seq data in which transcript-structure and close 
nucleotide-level inspection is required.

## Installation

You can install the development version from [GitHub](https://github.com/) with:

```{r, installation, eval = F}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("AngelCampos/txtools")
```

## Demo

### From genomic to transcriptomic

The main input that we want to process are Genomic Alignments from **BAM files**, 
into their transcriptomic homologues. To do this we require gene models
provided in the form of **BED-12 or BED-6 files**.

In this basic example we use data provided within **txtools**.

We first load the BAM file we want to process and the BED file's gene models, 
using the `tx_load_bam()` and `tx_load_bed()` functions.

```{r, example, message = FALSE}
# Load packages
library(txtools)

# This example files are installed along txtools
bamFile <- system.file("extdata", "example_hg19.bam", package = "txtools")
bedFile <- system.file("extdata", "twoUCSCgenes_hg19.bed", package = "txtools")

# Loading files and processing them using the gene models
reads <- tx_load_bam(bamFile, loadSeq = T, verbose = T, yieldSize = 10000)
geneAnnot <- tx_load_bed(bedFile) # plyranges read_bed function
```

The object `reads` now contains the aligned **genomic** reads, previously 
aligned with commonly used genomic aligners. Sorted BAM files make processing 
faster, see [samtools sort](https://www.htslib.org/doc/samtools-sort.html) for
more info on this.

For converting our loaded genomic reads to **transcriptomic** reads we use the
`tx_reads()`. Importantly, the function will assign mappings to their 
corresponding genes ONLY if they are consistent with the exon structure of the 
gene model. This allows to distinguish reads between different gene isoforms.

```{r}
txReads <- tx_reads(reads, geneAnnot, withSeq = T, verbose = T)
# txReads <- tx_reads_mc(reads, geneAnnot, nCores = 2,
                       # withSeq = T, verbose = T) # Multicore option
```

Currently, txtools is designed for and requires RNA-seq libraries that are 
**strand-specific**.

**To accelerate processing the multi-core function** `tx_reads_mc()` 
**is available for UNIX systems**

### Compatibility with GenomicRanges

Now `txReads` contains a list with all paired-end RNA-seq mappings divided by 
their corresponding gene models, along with their sequences as specified in the 
call to `tx_reads()`.

The resulting object is a GenomicRangesList (*GRangesList*) a list that contains 
*GenomicRanges* the core object of their homonymous package, but their 
coordinates belong now to the transcriptomic references used. In this way we can
take advantage of **GenomicRanges** functions and accesors to retrieve
information from the mappings, and manipulate them.

For example:

* The start of reads

```{r, message=F}
GenomicRanges::start(txReads)
```

* Extracting the ranges of the mappings for an specific gene using the `@ranges`
operator
```{r}
txReads$uc003lam.1@ranges # Ranges of reads in transcriptomic space
```

* Extracting meta columns, with additional data, using the mcols() function. 
In this case, we extract the values for the 6th mapping of the 'uc010nap.1'
gene.
```{r}
GenomicRanges::mcols(txReads$uc010nap.1)[6,]
```

Although using GenomicRanges functions may be useful in some cases for user 
specific tasks, txtools contains several functions that allow further 
processing and manipulation of the resulting transcriptomic mappings, and
are shown in the next sections.

### Raw Gene Counts

A common task in RNA-seq analysis workflows is simply counting the reads (or
mappings) that fall into a gene model to calculate gene expression levels. We 
can easily calculate that for all the genes using the `tx_counts()` function.

```{r}
tx_counts(txReads)
```

### Filtering

To control for spurious mappings we can filter for too long mappings, now in the
transcriptomic space, with the `tx_filter_max_width()` function. In this example
we set the threshold to 500, removing mappings longer than 500 nucleotides at 
the transcript level.

```{r}
txReads <- tx_filter_max_width(txReads, 300) # Filter out transcripts longer than 500 bases
tx_counts(txReads)
```

### Summarizing reads into data.tables (DT)

A useful representation of RNA-seq information we came up with is to summarise 
read metrics into tables spanning the whole transcript with information per 
nucleotide. Currently the metrics that we extract  are the following:

* Coverage
* Starts or 5'-ends counts
* Ends or 3'-ends counts
* Nucleotide frequencies
* Deletion frequencies

txtools provides three main functions to calculate all or parts of this 
information:

* `tx_coverageDT()`: Calculates coverage, read-starts, and read-ends
counts.

```{r, }
resTab1 <- tx_coverageDT(txReads, geneAnnot)
resTab1[[1]]
```

* `tx_nucFreqDT()`: Calculates the nucleotide frequency pileup.

```{r, }
resTab2 <- tx_nucFreqDT(txReads, geneAnnot)
resTab2[[1]]
```

* `tx_coverageDT()`: Calculates all previous (coverage, read-starts counts, and
read-ends counts, and nucleotide frequency).

```{r, }
resTab3 <- tx_covNucFreqDT(txReads, geneAnnot)
resTab3[[1]]

```

The resulting object is of class `data.table`. A fast and memory efficient 
relative to the data.frame.

The resulting data.table enables easy and fast access to data, ready for 
manipulation and analysis, for example, creating a barplot with the coverage 
column:

* Coverage barplot

```{r}
iGene <- "uc003lam.1"
barplot(resTab3[[iGene]]$cov, main = paste(iGene, "Coverage"),
        ylab = "Counts", xlab = iGene)
```

* Nucleotide frequency barplot

```{r}
iGene <- "uc010nap.1"
barplot(t(data.frame(resTab3[[iGene]][,c("A", "T", "G", "C", "N")])),
        col = c("#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "black"), border = "gray",
        main = paste("Nucleotide Frequency"), ylab = "Counts", xlab = iGene)
```

### Aggregating and splitting data.tables

Some features of data.tables can be only taken advantage when merging all the
data of the genes into one single data.table, we can do this with the 
`tx_merge_DT()` function. Similarly going back to gene independent data tables
is done with the `tx_split_DT()` function.

```{r}
# Merge
mergedDT <- tx_merge_DT(resTab1)
class(mergedDT)
# Split
split_DT <- tx_split_DT(mergedDT)
class(split_DT)
summary(split_DT)

```

A nice example of using data.tables is the x[i, j, by] syntax, which can be
used to apply functions to groups of values in the data.table. For example,
using the **merged data.table** we can calculate the median coverage per gene.

```{r}
mergedDT[,median(cov), by = gene]
```

We can see that the median coverage of "uc003lam.1" is 61 and for "uc010nap.1" 
is 10.

### Adding the reference sequence to the DT

When working with transcriptomic data one would like to easily get the 
relevant sequence. To add this info to a DT simply use the `tx_add_refSeqDT()` 
function.

Preparation: To use the `tx_add_refSeqDT()` function we need a reference genome.
In this case we use a BSgenome, a collection of pre-packaged genomes for 
easy installation. In this case we will use the BSgenome for human 
"BSgenome.Hsapiens.UCSC.hg19".

```{r}
# BiocManager::install("BSgenome.Hsapiens.UCSC.hg19") # Uncomment if you need to install
# Loading reference genome
genome <- BSgenome.Hsapiens.UCSC.hg19::BSgenome.Hsapiens.UCSC.hg19
# Adding the reference sequence to the summarized DT object
newDT <- tx_add_refSeqDT(resTab1$uc003lam.1, genome, geneAnnot)
newDT
```

### Writing individual DTs to files

Additionally, storing the tables in a file for later use can be done using the
**data.table** package, which allows for fast writing of data tables using the
function `fwrite()`

```{r, eval = F}
# Writes datatable to file
data.table::fwrite(mergedDT, "tableName.txt", sep = "\t")
```

## Soon to come features:
- **Complete function documentation & manual**
- **How to use guide and practical cases**
- **Graphical representations functions**
    + Coverage 
    + Nucleotide frequency 
    + Gene model ideogram
- **Whole Transcript reconstruction**
- **Meta-gene analysis tools**
    + Meta-gene plots

---

## Current limitations:

* Paired-end strand specific RNA-seq libraries: State of the art 
paired-end RNA-seq protocols provide strand awareness from the original RNA. 
Currently txtools is designed for such libraries, future improvements will enable 
processing of RNA-seq libraries which are not strand-aware nor paired-end.

* Insertions: txtools is not able to deal with insertions. This is mainly
because insertions are not part of the original trasncriptomic reference space
as they would alter the length of the gene model. This could be fixed in
future versions but is not a priority. 

* High processing time: Loading BAM files into R commonly requires a lot of time,
having this in mind txtools provides a progress bar to keep users informed about
the loading status. Also, depending on the ammount of both loaded reads and
the size of the *Gene Annotation* tx_reads() processing time can take several
minutes. We will work hard to take this processing time as low as possible in 
future versions.

## Additional notes:

* As many R packages meant for high-throughput data manipulation and analysis, 
using ***txtools*** may require high ammounts of RAM memory, mainly depending on
the size of BAM files loaded.

## Session Info
```{r}
utils::sessionInfo()
```
